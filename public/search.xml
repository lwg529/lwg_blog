<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019学习目标]]></title>
    <url>%2F2019%2F03%2F11%2F2019%E5%B9%B4%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[前言工作一年多快2年了，中间还换了一次工作，2019，不忘初心，给自己一个目标，并努力的实现，越努力，越幸运。 目标 读6本书，红宝书， es6，react，不知道的js 写博客，1月2篇，共24篇 刷题，一天一道，365道题 其他书籍读2-4本]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js数据类型判断和转换]]></title>
    <url>%2F2019%2F03%2F11%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E5%92%8C%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[前言无论笔试还是面试，总会问到数据类型和隐式转换。今天彻底整理一下这块的知识，希望对大家有帮助。 看到下面的题，是不是已经蒙了，读完这篇文章，就能顺利通关了1234567891011121314151617181920212223console.log([] == 0) //true console.log(![] == 0) //true console.log([] == ![]) //trueconsole.log([] == []) //falseconsole.log(&#123;&#125; == &#123;&#125;) //falseconsole.log(&#123;&#125; == !&#123;&#125;) //falseconsole.log([] == false) //trueconsole.log(&#123;&#125; == false) //falseif([]) &#123;console.log(3)&#125; //3 if([1] == [1])&#123;console.log(4)&#125; //没有输出console.log(&apos;2&apos; &gt; 10) //falseconsole.log(&apos;2&apos; &gt; &apos;10&apos;) //true 数据类型判断数据类型js数据类型一共有7种，undefined、 null、 boolean 、string、 number、 object、 Symbol 类型判断typeof12345678910111213typeof undefined //undefinedtypeof true //booleantypeof 42 //numbertypeof &apos;42&apos; //stringtypeof &#123; life: 42 &#125; //objectlet s = Symbol();typeof s //symbol//特殊情况typeof [1,2,3,4]// objecttypeof null //objecttypeof new Date() //objecttypeof function () &#123;&#125; //function 由此可以看出，typeof不能区分数组， null和对象 Object.prototype.toString.call1234567891011121314151617let getType=Object.prototype.toString;getType.call(undefined) //[object Undefined]console.log(getType.call(true)) //[object Boolean]console.log(getType.call(42)) //[object Number]console.log(getType.call(Symbol()))//[object Symbol]console.log(getType.call([1,2,3,4])) //[object Array]console.log(getType.call(null))//[object Null]console.log(getType.call(new Date())) //[object Date]console.log(getType.call(function () &#123;&#125; )) //[object Function] instanceofinstanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。 instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。 12new Date instanceof Date //true[1,2,3] instanceof Array //true instanceof运算符只能用于对象，不适用原始类型的值。 constructor 属性prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。 12function P() &#123;&#125;P.prototype.constructor === P // true 12[1,2].constructor === Array //true&apos;123&apos;.constructor === String //true 面试常问怎么判断是不是数组instanceof、constructor、Object.prototype.toString.call、Array.isArray 1234[1,2] instanceof Array //true[1,2].constructor === Array //trueObject.prototype.toString.call([1,2]) === &apos;[object Array]&apos; //trueArray.isArray([1,2]) //true 如何判断一个对象是不是空对象转换成json字符串判断1JSON.stringify(&#123;&#125;) == &quot;&#123;&#125;&quot; for in 循环判断 1234567let isEmptyObject = function(obj) &#123; for (let key in obj) &#123; return false; &#125; return true;&#125;console.log(isEmptyObject(obj));//true 使用ES6的Object.keys() 1Object.keys(&#123;&#125;).length === 0 类似的数组转化成数组类数组和数组都可以读写，获取长度，遍历，但是类数组不能调用数组的方法，比如push等 1Array.prototype.slice.call(arguments) 或者Array.from(arguments) 字符串翻转‘abc’.split(‘’).reverse().join(‘’) 字符串和数组转换[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].join(&#39;&#39;) //&#39;abc&#39;1&apos;abc&apos;.split(&apos;&apos;) //[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 类型转换显示类型转换转成数字，Number()、parseInt()、parseFloat()123456789101112131415161718192021222324252627282930// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&apos;324&apos;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&apos;324abc&apos;) // NaN// 空字符串转为0Number(&apos;&apos;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0//对象转化Number(&#123;a: 1&#125;) // NaNNumber(&#123;&#125;) //NaN //数组Number([1, 2, 3]) // NaNNumber([5]) // 5Number([]) //0 Number方法参数是对象时转换规则 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 转换规则示例： 123456789var obj = &#123;x: 1&#125;;Number(obj) // NaN// 等同于if (typeof obj.valueOf() === &apos;object&apos;) &#123; Number(obj.toString());&#125; else &#123; Number(obj.valueOf());&#125; 先使用valueOf返回了对象本身，再代用toString()返回了”[object Object]” 注意：任何涉及NaN的操作都返回NaN，NaN和任何值不相等 Boolean除了以下值的转换结果为false，其他的值全部为true。 false, &#39;&#39;, 0, NaN, null, undefined String函数可以将任意类型的值转化成字符串（1）原始类型值 123456789101112131415//数值：转为相应的字符串。String(123) // &quot;123&quot;//字符串：转换后还是原来的值。String(&apos;abc&apos;) // &quot;abc&quot;//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;。String(true) // &quot;true&quot;//undefined：转为字符串&quot;undefined&quot;。String(undefined) // &quot;undefined&quot;//null：转为字符串&quot;null&quot;。String(null) // &quot;null&quot; （2）对象 123456//String方法的参数如果是对象，返回一个类型字符串String(&#123;a: 1&#125;) // &quot;[object Object]&quot;//如果是数组，返回该数组的字符串形式。String([1, 2, 3]) // &quot;1,2,3&quot; String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 隐式类型转换自动转化为布尔值if条件，while, 自动转换为字符串主要发生在字符串加法，一个值为字符串，另一个非字符串，则后者直接转为字符串 123&apos;5&apos; + 1 // &apos;51&apos;&apos;5&apos; + true // &quot;5true&quot;&apos;5&apos; + &#123;&#125; // &quot;5[object Object]&quot; 自动转化为数值除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。 12345++/--(自增自减运算符) + - * / %(算术运算符) + &gt; &lt; &gt;= &lt;= == != === !=== (关系运算符) 12345678910111213&apos;5&apos; - &apos;2&apos; // 3&apos;5&apos; * &apos;2&apos; // 10true - 1 // 0false / &apos;5&apos; // 0//&apos;abc&apos;转为数值为NaN,NaN任何运算都是NaN&apos;abc&apos; - 1 // NaN//null进行Number运算转成0null + 1 // 1//undefined转为数值时为NaNundefined + 1 // NaN == 运算符（1）原始类型的数据会转换成数值类型再进行比较。 123456789101112131415161718192021222324252627281 == true // true// 等同于 1 === Number(true)0 == false // true// 等同于 0 === Number(false)2 == true // false// 等同于 2 === Number(true)&apos;true&apos; == true // false// 等同于 Number(&apos;true&apos;) === Number(true)// 等同于 NaN === 1&apos;&apos; == 0 // true// 等同于 Number(&apos;&apos;) === 0// 等同于 0 === 0&apos;&apos; == false // true// 等同于 Number(&apos;&apos;) === Number(false)// 等同于 0 === 0&apos;1&apos; == true // true// 等同于 Number(&apos;1&apos;) === Number(true)// 等同于 1 === 1&apos;\n 123 \t&apos; == 123 // true// 因为字符串转为数字时，省略前置和后置的空格 （2）对象与原始类型值比较 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。 12345678[1] == 1 // true// 等同于 Number([1]) == 1[1] == &apos;1&apos; // true// 等同于 Number([1]) == Number(&apos;1&apos;)[1] == true // true// 等同于 Number([1]) == Number(true) 实战练习12345678910111213141516171819202122232425262728293031323334353637383940//true,空数组valueOf还是空数组，toString()转成得到空字符串，空字符串调用Number转成0console.log([] == 0) //true //true，非的运算级别高，空数组转为布尔值为true,所以![]得到的false，Number转换为0， 最后结果还是trueconsole.log(![] == 0) //true //true,前面是调用valueOf()后调用toString()转成false，后边是非转成falseconsole.log([] == ![]) //false，2个数组放在堆里面，栈中存储的是地址console.log([] == []) //引用类型存储在堆中，栈中的是地址，所以是falseconsole.log(&#123;&#125; == &#123;&#125;) //&#123;&#125;.valueOf().toString()得到的是[object, Object], !&#123;&#125;得到的是false，Number转换后不相等console.log(&#123;&#125; == !&#123;&#125;)//数组的valueOf().toString()后为空，所以是真console.log([] == false) //true//因为对象调用valueOf后为&#123;&#125;, toString后转为[object, Object]，Number后是NaN,//任何涉及NaN的操作都返回NaN，NaN和任何值不相等console.log(&#123;&#125; == false) //false//空数组的boolean值为trueif([]) &#123;console.log(3)&#125; //3 //2个数组的栈地址不同if([1] == [1])&#123;console.log(4)&#125; //没有输出//false,转成2&gt;10console.log(&apos;2&apos; &gt; 10) //都是字符串，按照字符串的unicode转换，&apos;2&apos;.charCodeAt() &gt; &apos;10&apos;.charCodeAt = 50 &gt; 49console.log(&apos;2&apos; &gt; &apos;10&apos;) //都是字符串，按照字符串的unicode转换console.log(&apos;abc&apos; &gt; &apos;b&apos;) //false 参考：http://javascript.ruanyifeng.com/grammar/conversion.html]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
</search>
